<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive 4D Hypercube</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000000;
        font-family: sans-serif;
        color: #0f0;
      }
      canvas {
        display: block;
      }
      #controls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        display: flex;
        gap: 10px;
      }
      button {
        border: none;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: rgba(51, 51, 51, 0.5);
        color: #f5f5f5;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <button id="zoomIn">+</button>
      <button id="zoomOut">-</button>
    </div>
    <canvas id="c"></canvas>
    <script>
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");
      let w = (canvas.width = window.innerWidth);
      let h = (canvas.height = window.innerHeight);
      window.addEventListener("resize", () => {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
      });

      let zoom = 1;
      document.getElementById("zoomIn").onclick = () => {
        zoom *= 1.2;
      };
      document.getElementById("zoomOut").onclick = () => {
        zoom /= 1.2;
      };

      const sin = Math.sin,
        cos = Math.cos;

      class Vec4 {
        constructor(x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
        }
        add(v) {
          return new Vec4(
            this.x + v.x,
            this.y + v.y,
            this.z + v.z,
            this.w + v.w
          );
        }
        scale(s) {
          return new Vec4(this.x * s, this.y * s, this.z * s, this.w * s);
        }
      }

      function rotation4DXY(theta) {
        return [
          [cos(theta), -sin(theta), 0, 0],
          [sin(theta), cos(theta), 0, 0],
          [0, 0, 1, 0],
          [0, 0, 0, 1],
        ];
      }
      function rotation4DXZ(theta) {
        return [
          [cos(theta), 0, -sin(theta), 0],
          [0, 1, 0, 0],
          [sin(theta), 0, cos(theta), 0],
          [0, 0, 0, 1],
        ];
      }
      function rotation4DYZ(theta) {
        return [
          [1, 0, 0, 0],
          [0, cos(theta), -sin(theta), 0],
          [0, sin(theta), cos(theta), 0],
          [0, 0, 0, 1],
        ];
      }
      function rotation4DXW(theta) {
        return [
          [cos(theta), 0, 0, -sin(theta)],
          [0, 1, 0, 0],
          [0, 0, 1, 0],
          [sin(theta), 0, 0, cos(theta)],
        ];
      }
      function rotation4DYW(theta) {
        return [
          [1, 0, 0, 0],
          [0, cos(theta), 0, -sin(theta)],
          [0, 0, 1, 0],
          [0, sin(theta), 0, cos(theta)],
        ];
      }
      function rotation4DZW(theta) {
        return [
          [1, 0, 0, 0],
          [0, 1, 0, 0],
          [0, 0, cos(theta), -sin(theta)],
          [0, 0, sin(theta), cos(theta)],
        ];
      }
      function multMatVec(m, v) {
        return new Vec4(
          m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] * v.w,
          m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] * v.w,
          m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] * v.w,
          m[3][0] * v.x + m[3][1] * v.y + m[3][2] * v.z + m[3][3] * v.w
        );
      }

      let cubeVertices = [];
      for (let i = 0; i < 16; i++) {
        let x = i & 1 ? 1 : -1;
        let y = i & 2 ? 1 : -1;
        let z = i & 4 ? 1 : -1;
        let wv = i & 8 ? 1 : -1;
        cubeVertices.push(new Vec4(x, y, z, wv));
      }

      let edges = [];
      for (let i = 0; i < 16; i++) {
        for (let j = i + 1; j < 16; j++) {
          let diff = 0;
          if (cubeVertices[i].x !== cubeVertices[j].x) diff++;
          if (cubeVertices[i].y !== cubeVertices[j].y) diff++;
          if (cubeVertices[i].z !== cubeVertices[j].z) diff++;
          if (cubeVertices[i].w !== cubeVertices[j].w) diff++;
          if (diff === 1) edges.push([i, j]);
        }
      }

      let angle = 0;
      let rotationOffsetX = 0,
        rotationOffsetY = 0;
      let isDragging = false,
        lastX,
        lastY;

      canvas.addEventListener("mousedown", (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      canvas.addEventListener("mousemove", (e) => {
        if (isDragging) {
          rotationOffsetY += (e.clientX - lastX) * 0.005;
          rotationOffsetX += (e.clientY - lastY) * 0.005;
          lastX = e.clientX;
          lastY = e.clientY;
        }
      });
      canvas.addEventListener("mouseup", () => {
        isDragging = false;
      });
      canvas.addEventListener("mouseleave", () => {
        isDragging = false;
      });

      canvas.addEventListener("touchstart", (e) => {
        isDragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      });
      canvas.addEventListener(
        "touchmove",
        (e) => {
          if (isDragging) {
            rotationOffsetY += (e.touches[0].clientX - lastX) * 0.005;
            rotationOffsetX += (e.touches[0].clientY - lastY) * 0.005;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
            e.preventDefault();
          }
        },
        { passive: false }
      );
      canvas.addEventListener("touchend", () => {
        isDragging = false;
      });

      function project4Dto3D(v) {
        return {
          x: (v.x * 200) / (2 - v.w),
          y: (v.y * 200) / (2 - v.w),
          z: (v.z * 200) / (2 - v.w),
        };
      }
      function project3Dto2D(v) {
        return { x: w / 2 + v.x * zoom * 1.5, y: h / 2 + v.y * zoom * 1.5 };
      }

      function animate() {
        ctx.clearRect(0, 0, w, h);
        angle += 0.01;
        let rotated = cubeVertices.map((v) => {
          let r = v;
          r = multMatVec(rotation4DXY(angle + rotationOffsetY), r);
          r = multMatVec(rotation4DXZ(angle / 2 + rotationOffsetX), r);
          r = multMatVec(rotation4DYW(angle / 3), r);
          r = multMatVec(rotation4DXW(angle / 4), r);
          return r;
        });
        let projected = rotated.map(project4Dto3D).map(project3Dto2D);
        ctx.strokeStyle = "#0f0";
        edges.forEach((e) => {
          ctx.beginPath();
          ctx.moveTo(projected[e[0]].x, projected[e[0]].y);
          ctx.lineTo(projected[e[1]].x, projected[e[1]].y);
          ctx.stroke();
        });
        ctx.fillStyle = "#f00";
        rotated.forEach((v, i) => {
          let p = project3Dto2D(project4Dto3D(v));
          ctx.beginPath();
          ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = "#0f0";
          ctx.fillText(
            `(${v.x.toFixed(2)},${v.y.toFixed(2)},${v.z.toFixed(
              2
            )},${v.w.toFixed(2)})`,
            p.x + 10,
            p.y - 10
          );
          ctx.fillStyle = "#f00";
        });
        requestAnimationFrame(animate);
      }
      animate();
    </script>
  </body>
</html>
